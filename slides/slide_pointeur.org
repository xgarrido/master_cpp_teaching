#+TITLE:  Pointeurs, Références & Allocation Dynamique de Mémoire
#+AUTHOR: Xavier Garrido
#+DATE:   15/09/2013
#+OPTIONS: toc:nil ^:{}
#+STARTUP:     beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [cpp_teaching, nologo]

* Rappels sur les adresses et pointeurs
:PROPERTIES:
:END:

- Tout objet manipulé par l'ordinateur est stocké en mémoire. Selon la nature de
  l'objet, l'espace en mémoire alloué varie : par ex., entier = 32 ou 64 bits

- *L'adresse* est l'endroit où se trouve la variable en mémoire. Elle s'obtient
  via la syntaxe suivante : =&NomDeLaVariable=

- L'adresse n'étant ni plus ni moins qu'une valeur, on peut donc stocker cette
  valeur dans une variable : *un pointeur* est ainsi un conteneur d'adresse

- Déclaration d'un pointeur :

  #+BEGIN_SRC c++
    int i = 10;
    int * pt_i = &i;
    int j = *pt_i;
  #+END_SRC

* Notion de référence en \Cpp

Le \Cpp introduit la notion de référence afin de faciliter la manipulation des
variables

** Pointeur
:PROPERTIES:
:BEAMER_COL: 0.3
:END:
#+BEGIN_SRC c++
  // Pointeur
  int i = 10;
  int * pt_i = &i;
  (*pt_i)++;
#+END_SRC

** Référence
:PROPERTIES:
:BEAMER_COL: 0.4
:END:
#+BEGIN_SRC c++
  // Référence
  int i = 10;
  int & ref_i = i;
  ref_i++;
#+END_SRC

** <empty>
:PROPERTIES:
:BEAMER_ENV: ignoreheading
:END:

#+BEAMER: \vskip +10pt
- La déclaration d'une référence ne crée pas de nouvel objet

- Toute référence doit se référer à un identificateur : =int & ref_i;= ne
  compilera pas. Il est nécessaire *d'initialiser* une référence.

- Une référence pointe toujours vers le même objet, on ne peut pas changer sa
  destination.

* Références en tant qu'arguments de fonctions

** Transmission par adresse
:PROPERTIES:
:BEAMER_COL: 0.5
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc]
:END:
#+BEGIN_SRC c++
  void echange (int * a, int * b)
  {
    int c = *a;
    *a = *b;
    *b = c;
  }
  ...
  int x = 10;
  int y = 20;
  echange (&x, &y);
#+END_SRC

#+BEAMER: \pause

** Transmission par référence
:PROPERTIES:
:BEAMER_COL: 0.5
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc]
:END:
#+BEGIN_SRC c++
  void echange (int & a, int & b)
  {
    int c = a;
    a = b;
    b = c;
  }
  ...
  int x = 10;
  int y = 20;
  echange (x, y);
#+END_SRC

* Allocation dynamique de mémoire

L'allocation dynamique de mémoire est nécessaire dès lors que la taille d'un
objet (ou sa nature) n'est connue que lors de l'exécution du programme. La
déclaration

#+BEGIN_SRC c++
  unsigned int n;
  std::cin >> n;
  double tableau[n];
#+END_SRC

est rejetée du fait que le compilateur ne connait pas, au préalable, l'espace
mémoire nécessaire à l'allocation.

* Utilisation des opérateurs =new= et =delete=

- Pour rappel, en langage C, la gestion dynamique de mémoire fait appel aux
  fonctions =malloc= et =free= (librairie =stdlib.h=)

- \Cpp propose deux nouveaux opérateurs :

  - =new= alloue une certaine quantité de mémoire et renvoie un pointeur sur le
    début du tableau :
    #+BEGIN_SRC c++
      unsigned int n;
      std::cin >> n;
      double * tableau = new double[n];
    #+END_SRC

  - =delete[]= libère l'espace mémoire :
    #+BEGIN_SRC c++
      delete[] tableau;
    #+END_SRC

* Portée & Durée de vie des variables

** Durée de vie limitée au bloc (ici boucle =for=)
:PROPERTIES:
:BEAMER_COL: 0.6
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc][\footnotesize]
:END:
#+BEGIN_SRC c++
  for (int i = 0; i < 10; i++)
    {
      int k = 0;
      // À la fin du bloc,
      // destruction de k
    }
#+END_SRC

#+BEAMER: \pause

** Durée de vie indépendante du bloc
:PROPERTIES:
:BEAMER_COL: 0.6
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc][\footnotesize]
:END:
#+BEGIN_SRC c++
  for (int i = 0; i < 10; i++)
    {
      int * k = new int (0);
      // À la fin du bloc,
      // k existe en mémoire
    }
#+END_SRC

#+ATTR_LATEX: :options [5][lrtuc][\centering][9][11]
#+BEGIN_CBOX
Fuite de mémoire garantie
#+END_CBOX

* Portée & Durée de vie des variables

** Durée de vie limitée au bloc (ici boucle =for=)
:PROPERTIES:
:BEAMER_COL: 0.6
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc][\footnotesize]
:END:
#+BEGIN_SRC c++
  for (int i = 0; i < 10; i++)
    {
      int k = 0;
      // À la fin du bloc,
      // destruction de k
    }
#+END_SRC

** Durée de vie indépendante du bloc
:PROPERTIES:
:BEAMER_COL: 0.6
:BEAMER_ENV: cbox
:BEAMER_OPT: [][lwuc][\footnotesize]
:END:
#+BEGIN_SRC c++
  for (int i = 0; i < 10; i++)
    {
      int * k = new int (0);
      delete k;

    }
#+END_SRC
