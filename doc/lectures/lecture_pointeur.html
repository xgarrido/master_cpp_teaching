<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pointeurs, références &amp; allocation dynamique de mémoire</title>
<!-- 2013-10-19 sam. 17:07 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><aa>Encapsulation des données </aa><aa>Notions de constructeur et de destructeur </aa><aa>Fonctions et classes amies </aa><aa>Surcharge d'opérateur </aa><aa>Héritage </aa><aa>Notions de patrons de fonctions et de classes </aa><aa>Introduction à la librairie standard STL </aa><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><aa>Les membres données statiques </aa><aa>Utilisation de enum et de typedef </aa>
                    <hr/>
                    <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Pointeurs, références &amp; allocation dynamique de mémoire</h1><hr/>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Rappels sur les adresses et les pointeurs</h2>
<div class="outline-text-2" id="text-1">
<p>
Une variable prend de l&rsquo;espace en mémoire. Par exemple, un entier <code>i</code> occupe 4
octets. L&rsquo;endroit où se trouve la variable <code>i</code> en mémoire est <b>l&rsquo;adresse</b> de
<code>i</code>. Inversement, l&rsquo;adresse en notation héxadécimale <code>0x22ff74A</code> correpond aux 4
octets soit 32 bits <code>01001001001001010010101010010101010</code> de l&rsquo;entier
<code>i</code>. L&rsquo;adresse d&rsquo;une variable est donnée par <code>&amp;nom_de_la_variable</code>.
</p>

<p>
De même qu&rsquo;une variable peut contenir des valeurs, un pointeur est un conteneur
d&rsquo;adresse. Au cours de sa brève vie, une variable peut valoir 12 puis 222 puis
-27 alors qu&rsquo;<b>un pointeur</b> désignera l&rsquo;adresse en mémoire soit, successivement,
<code>0x21fd740</code> puis <code>0x22ff74A</code> puis <code>0x22aa23B</code>.
</p>

<p>
Un pointeur possède lui aussi un &ldquo;type&rdquo;, à savoir que l&rsquo;adresse se réfère à un
type de données. En outre, un pointeur occupe lui aussi de l&rsquo;espace mémoire. Il
prend 2 octets qui servent à conserver l&rsquo;adresse. On peut donc créer des
pointeurs sur des pointeurs&#x2026;
</p>

<p>
La déclaration d&rsquo;un pointeur se présente de la façon suivante
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">D&#233;claration</span>
<span class="org-type">type_du_pointeur</span> *<span class="org-variable-name">nom_pointeur</span>;
</pre>
</div>
<p>
tandis que son affectation s&rsquo;écrira
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">Affectation</span>
nom_pointeur = adresse_de_la_variable;
</pre>
</div>

<p>
Exemple:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> <span class="org-variable-name">i</span>;
<span class="org-type">int</span> *<span class="org-variable-name">pt_i</span>;
pt_i = &amp;i;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Allocation dynamique de mémoire <i>via</i> les opérateurs <code>new</code> et <code>delete</code></h2>
<div class="outline-text-2" id="text-2">
<p>
La dimension d&rsquo;un tableau statique, doit être connue du compilateur au moment
même de la compilation. Une déclaration telle que <code>int n; double tableau[n];</code>
sera rejeté du fait que le compilateur ne connaît pas, au préalable, l&rsquo;espace
mémoire nécessaire à l&rsquo;allocation.
</p>

<p>
Dans l&rsquo;hypothèse où la taille d&rsquo;un objet n&rsquo;est connue que lors de l&rsquo;exécution du
programme, il est alors inévitable <b>d&rsquo;allouer dynamiquement de la mémoire</b>,
c&rsquo;est-à-dire de réserver de la mémoire <b>alors que le programme</b> est en cours
d&rsquo;exécution.
</p>

<p>
En langage C, la gestion dynamique de mémoire fait appel aux fonctions <code>malloc</code>
et <code>free</code>. Si comme toutes fonctions standards leur implémentation est possible
en C++, leur utilisation demeure lourde et non adaptée à la programmation
orientée objet. Le C++ propose deux nouveaux opérateurs <code>new</code> et <code>delete</code> pour
gérer l&rsquo;allocation dynamique de mémoire.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Utilisation de l&rsquo;opérateur <code>new</code></h3>
<div class="outline-text-3" id="text-2-1">
<p>
De même que <code>malloc</code> le faisait en C, <code>new</code> alloue une certaine quantité de
mémoire pour notre tableau et renvoie un pointeur sur le début du tableau. La
syntaxe est la suivante
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">type</span> * <span class="org-variable-name">pt_tableau</span> = <span class="org-keyword">new</span> <span class="org-type">type</span>[nbr_element];
</pre>
</div>
<p>
Exemple
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> *<span class="org-variable-name">pt_tableau</span>;
<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">n_dimension_tableau</span> = 666;
pt_tableau = <span class="org-keyword">new</span> <span class="org-type">int</span>[n_dimension_tableau];
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Utilisation de l&rsquo;opérateur <code>delete[]</code></h3>
<div class="outline-text-3" id="text-2-2">
<p>
De même que <code>free</code> libérait l&rsquo;espace alloué par <code>malloc</code> en C, <code>delete[]</code> libère
l&rsquo;espace mémoire alloué par l&rsquo;opérateur <code>new</code>. Ainsi,
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">delete</span>[] pt_tableau;
</pre>
</div>
<p>
restaurera l&rsquo;espace mémoire précédemment alloué pour 666 valeurs entières.
</p>

<p>
De manière générale, l&rsquo;utilisation de l&rsquo;opérateur <code>new</code> implique nécessairement
l&rsquo;utilisation de sa contrepartie <code>delete</code>. Dans le cas contraire, des fuites de
mémoire, <i>i.e.</i> de la perte de mémoire libre au profit d&rsquo;objet qui n&rsquo;existent
plus, sont à craindre et peuvent, sous certaines conditions, rendrent le système
totalement inutilisable.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Référence</h2>
<div class="outline-text-2" id="text-3">
<p>
Une référence permet de donner deux noms différents pour une seule et même case
mémoire.
</p>

<p>
Les références servent rarement directement. Le principal intérêt de la notion
de référence est qu&rsquo;elle permet de laisser le compilateur mettre en œuvre les
instructions adéquates pour le transfert par adresse (<i>cf.</i> <a href="lecture_fonction.html">&ldquo;Rappels sur les
fonctions&rdquo;</a>).
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
<span class="org-comment-delimiter">// </span><span class="org-comment">j est une r&#233;f&#233;rence de i</span>
<span class="org-type">int</span> &amp;<span class="org-variable-name">j</span> = i;
<span class="org-comment-delimiter">// </span><span class="org-comment">j et i repr&#233;sentent alors la m&#234;me case m&#233;moire</span>
</pre>
</div>

<p>
Une référence nécessite obligatoirement une initialisation vers une variable
qu&rsquo;elle va référencer. En outre, une référence pointe toujours vers le même
objet; on ne pourra donc changer sa destination.
</p>
</div>
</div>
</div>
</body>
</html>
