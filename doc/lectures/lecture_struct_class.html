<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Structures et classes</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><a href="lecture_encapsulation.html">Encapsulation des données </a><a href="lecture_constructeur.html">Notions de constructeur et de destructeur </a><a href="lecture_amitie.html">Fonctions et classes amies </a><a href="lecture_surcharge.html">Surcharge d'opérateur </a><a href="lecture_heritage.html">Héritage </a><a href="lecture_template.html">Notions de patrons de fonctions et de classes </a><a href="lecture_librairie_standard.html">Introduction à la librairie standard STL </a><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><a href="annexe_variable_statique.html">Les membres données statiques </a><a href="annexe_enum_typedef.html">Utilisation de enum et de typedef </a>
                    <hr/>
                    <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Structures et classes</h1><hr/>
<p>
Ce chapitre aborde véritablement les possibilités offertes par la programmation
orientée objet grâce à l&rsquo;implémentation des classes. Une classe est la
généralisation de la notion de type défini par l&rsquo;utilisateur, dans lequel se
trouvent associées aussi bien <b>des données (membres données)</b> que <b>des méthodes</b>
(fonctions membres). En règle générale, il existe une nette distinction entre
les données d&rsquo;un programme et le code exécutable des fonctions de ce
programme. En effet, les données et le code ne se mélangent généralement pas
dans la mémoire de l&rsquo;ordinateur (sauf cas très particuliers tels que
l&rsquo;autoprogrammation, les virus ou encore les débogueurs). Les langages objet
permettent, par l&rsquo;intermédiaire de constructions syntaxiques relativement
simples, de définir de manière groupée les données à manipuler et les opérations
qu&rsquo;on peut leur appliquer. Dans ce cadre, <b>un objet</b> n&rsquo;est rien d&rsquo;autre que des
données qui le caractérisent, sur lesquelles des traitements spécifiques peuvent
être appliqués.
</p>

<p>
Par ailleurs, la programmation orientée objet ne se conçoit que dans le contexte
d&rsquo;une analyse du problème à traiter plus &ldquo;orientée&rdquo; sur la nature et la
structure des données manipulées (autrement dit, les objets) et des opérations
associées que sur la séquence des traitements que le programme doit
effectuer. Elle se distingue en cela de la programmation impérative (ou
procédurale) classique telle qu&rsquo;utilisée en C ou fortran, qui s&rsquo;intéresse plus à
l&rsquo;algorithmique qu&rsquo;aux structures de données.
</p>

<p>
En pratique, il est courant que plusieurs objets aient la même structure de
données et puissent subir les même traitements. On considère dans ce cas que ces
objets sont de même nature, et sont en réalité <b>des instances</b> d&rsquo;une même classe
d&rsquo;objets. La classe d&rsquo;un objet apparaît donc réellement comme son type de
données, définissant sa structure et les opérations qui peuvent lui être
appliquées.
</p>

<p>
Dans ce premier chapitre consacré à la programmation orientée objet, nous
présenterons la version étendue du type structure introduite par le C++. Ce
nouveau type permettra, dans un premier temps, de nous limiter à la façon de
mettre en œuvre l&rsquo;association des données et des méthodes et facilitera
l&rsquo;introduction à la notion même de classe. Ce n&rsquo;est qu&rsquo;au travers du prochain
chapitre <a href="lecture_encapsulation.html">&ldquo;Encapsulation des données&rdquo;</a> qu&rsquo;apparaîtont les différences
conceptuelles entre les types structure et classe.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Les structures en C++</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Rappel : les structures en C</h3>
<div class="outline-text-3" id="text-1-1">
<p>
En C, une déclaration telle que
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">point</span>
{
  <span class="org-type">int</span> <span class="org-variable-name">m_X</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_Y</span>;
};
</pre>
</div>

<p>
définit un type structure nommé <code>point</code> dont <code>m_X</code> et <code>m_Y</code> sont des
<b>membres</b>. On notera, par ailleurs, la présence d&rsquo;un point virgule à la fin de
la déclaration. L&rsquo;instanciation c&rsquo;est-à-dire la déclaration d&rsquo;objet de type
<code>point</code> se fait <i>via</i> des instructions telles que
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">point</span> <span class="org-variable-name">my_point1</span>, <span class="org-variable-name">my_point2</span>;
</pre>
</div>

<p>
L&rsquo;accès aux membres de <code>my_point1</code> et <code>my_point2</code> se fait à l&rsquo;aide de l&rsquo;opérateur
point (<code>.</code>); par exemple, <code>my_point1.y</code> désigne le membre <code>y</code> de la structure
<code>my_point1</code>.
</p>
</div>
</div>
<div id="outline-container-ref::declaration" class="outline-3">
<h3 id="ref::declaration"><a id="sec-1-2" name="sec-1-2"></a>Déclaration d&rsquo;une structure comportant des méthodes ou  fonctions membres</h3>
<div class="outline-text-3" id="text-ref::declaration">
<p>
En C++, il est possible au sein même d&rsquo;une structure, d&rsquo;associer aux données
<i>i.e.</i> aux membres, <b>des méthodes</b> également appelées &ldquo;fonction
membres"<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>. Supposons que nous souhaitions associer à la structure <code>point</code>
précédente, trois fonctions:
</p>

<ul class="org-ul">
<li><code>initialise</code> pour attribuer des valeurs aux &ldquo;coordonnées&rdquo; d&rsquo;un point,
</li>

<li><code>deplace</code> pour modifier les coordonnées d&rsquo;un point,
</li>

<li><code>affiche</code> pour afficher les coordonnées d&rsquo;un point.
</li>
</ul>

<p>
De telles méthodes seraient ainsi déclarées
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">point</span>
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">D&#233;claration des membres</span>
  <span class="org-type">int</span> <span class="org-variable-name">m_X</span>;
  <span class="org-type">int</span> <span class="org-variable-name">m_Y</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">D&#233;claration des m&#233;thodes ou fonctions membres</span>
  <span class="org-type">void</span> <span class="org-function-name">initialise</span> (<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">abscisse</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">ordonnee</span>);
  <span class="org-type">void</span> <span class="org-function-name">deplace</span>    (<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">new_abscisse</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">new_ordonnee</span>);
  <span class="org-type">void</span> <span class="org-function-name">affiche</span>    ();
};
</pre>
</div>

<p>
Outre la déclaration classique des membres de la structure apparaissent les
déclarations ou prototypes des trois fonctions. Notez bien que la définition de
ces méthodes ne figure pas à ce niveau de simple déclaration. En revanche, le
type d&rsquo;arguments à fournir aux différentes méthodes est précisé<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup> bien
que l&rsquo;usage de ces variables soit à ce stade de la déclaration inconnu.
</p>
</div>
</div>
<div id="outline-container-ref::definition" class="outline-3">
<h3 id="ref::definition"><a id="sec-1-3" name="sec-1-3"></a>Définition des méthodes</h3>
<div class="outline-text-3" id="text-ref::definition">
<p>
La définition des méthodes se fait comme une fonction à ceci près que le nom de
la structure doit être précisé afin d&rsquo;évaluer &ldquo;la portée&rdquo; de cette fonction. À
titre d&rsquo;exemple, la méthode <code>initialise</code> pourra être définie ainsi
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">void</span> <span class="org-constant">point</span>::<span class="org-function-name">initialise</span> (<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">abscisse</span>, <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">ordonnee</span>)
{
  m_X = abscisse;
  m_Y = ordonnee;
}
</pre>
</div>

<p>
Dans l&rsquo;en-tête, le nom de la méthode est <code>point::initialise</code> où le symbole <code>::</code>
correspond à l&rsquo;opérateur de résolution de portée. Ce dernier sert à modifier la
portée d&rsquo;un identificateur; dans le cas présent, il signifie que
l&rsquo;identificateur <code>initialise</code> concerné relève de la structure <code>point</code>.
</p>

<p>
Dans le détail de la définition, deux affectations sont réalisées: celle de la
valeur <code>abscisse</code>, respectivement <code>ordonnee</code>, vers la variable <code>m_X</code>,
respectivement <code>m_Y</code>. Le variable <code>m_X</code> n&rsquo;est ni un argument ni une variable
locale à la méthode; <code>m_x</code> désigne le membre <code>m_X</code> correspondant au type
<code>point</code>. Il est important de noter qu&rsquo;une telle association entre méthode et
données membres d&rsquo;une structure n&rsquo;est réalisée qu&rsquo;au travers du préfixe
<code>point::</code>. En l&rsquo;absence de ce &ldquo;préfixe&rdquo;, nous définirions effectivement une
fonction nommée <code>initialise</code>, indépendante de la structure <code>point</code>, et ne
pouvant accéder et donc modifier les membres <code>m_X</code> et <code>m_Y</code>.
</p>

<p>
En outre, la définition de la méthode <code>initialise</code> et de ces consœurs <code>deplace</code>
et <code>affiche</code>, ne peut être compilée seules. Elle nécessite l&rsquo;inclusion des
instructions de déclaration correspondantes et présentées plus tôt dans le
paragraphe. Dans la pratique, la déclaration de la structure trouvera
naturellement sa place au sein d&rsquo;un fichier d&rsquo;en-tête dûment nommé (<code>point.h</code>,
par exemple) tandis que la définition des méthodes s&rsquo;insèrera dans un fichier
source (<code>point.cc</code>, par exemple). L&rsquo;inclusion du fichier d&rsquo;en-tête au sein du
fichier source est alors impérative.
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Utilisation d&rsquo;une structure comportant des méthodes</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Disposant à présent du type <code>point</code> tel que déclaré au paragraphe
<a href="#ref::declaration">Déclaration d&rsquo;une structure comportant des méthodes ou  fonctions membres</a> et défini au paragraphe <a href="#ref::definition">Définition des méthodes</a>, nous pouvons
déclarer autant d&rsquo;objets <i>i.e.</i> de structures de type <code>point</code>. L&rsquo;instruction
suivante
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">point</span> <span class="org-variable-name">my_point1</span>, <span class="org-variable-name">my_point2</span>;
</pre>
</div>

<p>
déclare deux structures nommées <code>my_point1</code> et <code>my_point2</code>, chacune disposant de
trois méthodes <code>initialise</code>, <code>deplace</code> et <code>affiche</code>. L&rsquo;accès aux membres <code>m_X</code>
et <code>m_Y</code> peut se faire comme en C à savoir <code>my_point1.m_X = 5;</code>. Cependant et
comme nous le verrons au prochain chapitre <a href="lecture_encapsulation.html"><i>Encapsulation des données</i></a>, nous
briserions alors le principe d&rsquo;encapsulation à savoir que nous accèderions
directement aux données membres sans passer par l&rsquo;intermédiaire des
méthodes. Aussi, on priviligiera la manipulation des membres <i>via</i> les méthodes
dédiées soit
</p>

<div class="org-src-container">

<pre class="src src-c++">mypoint1.initialise (5, 2);
</pre>
</div>

<p>
Une telle instruction consiste à appeler la méthode <code>Initialise</code> <b>pour la
structure <code>my_point1</code></b> en lui transmettant en arguments les valeurs 5
et 2. Abstraction faite du préfixe <code>my_point1.</code>, cet appel est analogue à un
appel classique de fonction. Aussi, l&rsquo;ajout du préfixe <code>my_point1.</code> précise à la
méthode quelle est la structure sur laquelle opérer.
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Remarques</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Une méthode ne peut être appelée comme une fonction ordinaire. Par exemple,
l&rsquo;instruction suivante
<div class="org-src-container">

<pre class="src src-c++">initialise (5, 2);
</pre>
</div>
<p>
sera rejetée à la compilation (à moins qu&rsquo;il n&rsquo;existe, par ailleurs, une
fonction ordinaire appelée <code>initialise</code>).
</p>
</li>

<li>Dans la déclaration d&rsquo;une structure, il est permis (mais généralement peu
conseillé) d&rsquo;introduire les membres et les méthodes dans un ordre quelconque.
</li>

<li>Un exemple de programme complet comprendrait

<ul class="org-ul">
<li>la déclaration du type <code>point</code>,
</li>
<li>la définition des méthodes du type <code>point</code>,
</li>
<li>un programme principal contenant la fonction <code>main</code> et utilisant le type <code>point</code>.
</li>
</ul>
<p>
La compilation séparée prend alors tout son intérêt puisqu&rsquo;il est possible de
compiler le type <code>point</code> indépendamment de son utilisation faite dans le
programme principal; c&rsquo;est ainsi que l&rsquo;on pourra &ldquo;réutiliser&rdquo; un composant logiciel.
</p>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Notion de classe</h2>
<div class="outline-text-2" id="text-2">
<p>
En C++, la structure est un cas particulier de la classe. Comme nous le verrons
au prochain chapitre, une classe est une structure dans laquelle seulement
certains membres et/ou méthodes sont accessibles &ldquo;de l&rsquo;extérieur&rdquo;: on parlera
alors de membres/méthodes &ldquo;publics&rdquo; par opposition aux membres/méthodes dites
&ldquo;privés&rdquo;. Toutefois, dans le cadre de ce chapitre d&rsquo;introduction aux notions de
structure/classe, la déclaration d&rsquo;une classe est voisine de celle d&rsquo;une
structure à ceci près que le mot clé <code>struct</code> est remplacé par le terme
<code>class</code>. Par ailleurs, pour avoir un comportement identique à celui d&rsquo;une
structure, il convient d&rsquo;ajouter le mot clé <code>public</code> afin que membres et
méthodes soient accessibles et manipulables depuis l&rsquo;extérieur de la classe. Par
défaut, les membres et méthodes d&rsquo;une classe sont privés (mot clé <code>private</code>)
alors que ceux d&rsquo;une structure sont publics. L&rsquo;ensemble de ces concepts est
précisé dans le chapitre <a href="lecture_encapsulation.html"><i>Encapsulation des données</i></a>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
d&rsquo;un point de vue conceptuel, une telle notion ne prendra tout son
intérêt qu&rsquo;une fois l&rsquo;encapsulation des données introduite. Cependant, la
présentation du concept de méthode prépare à la notion de classe.
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
l&rsquo;ajout des noms des variables est facultative. Toutefois, elle facilite
la lecture et la compréhension du code, <i>a fortiori</i> pour l&rsquo;utilisateur qui
n&rsquo;a, en théorie, accès qu&rsquo;à la déclaration des méthodes et non à leur
définition.
</p></div>


</div>
</div></div>
</body>
</html>
