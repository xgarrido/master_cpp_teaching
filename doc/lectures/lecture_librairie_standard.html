<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Introduction à la librairie standard STL</title>
<!-- 2013-10-19 sam. 16:36 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><aa>Encapsulation des données </aa><aa>Notions de constructeur et de destructeur </aa><aa>Fonctions et classes amies </aa><aa>Surcharge d'opérateur </aa><aa>Héritage </aa><aa>Notions de patrons de fonctions et de classes </aa><aa>Introduction à la librairie standard STL </aa><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><aa>Les membres données statiques </aa><aa>Utilisation de enum et de typedef </aa>
                    <hr/>
                    <a href="../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Introduction à la librairie standard STL</h1><hr/>
<p>
Le langage C++ en lui-même ne fournit que très peu d&rsquo;outils pour la gestion des
chaînes de caractères, les entrées/sorties et les collections (que l&rsquo;on regroupe
communément sous l&rsquo;appelation de containers), car il n&rsquo;ajoute pour ces besoins
rien par rapport au C.
</p>

<p>
La librairie standard STL (<i>Standard Template Library</i>) du C++ apporte donc une
réponse standardisée et exploitant très largement les mécanismes étendus du C++
par rapport à C, que sont :
</p>

<ul class="org-ul">
<li>l&rsquo;approche objet et les capacités d&rsquo;abstraction en particulier sur les
opérateurs,
</li>

<li>les patrons de classe,
</li>

<li>la surdéfinition des opérateurs.
</li>
</ul>

<p>
Cette bibliothèque implémente un grand nombre de classe patron décrivant des
containers génériques pour le langage C++ afin de pallier aux limitations
intrinsèques au langage C. La STL fournit de plus des algorithmes permettant de
manipuler aisément ces containers (pour les initialiser, rechercher des valeurs,
&#x2026;). D&rsquo;autre part, la STL introduit également le concept d&rsquo;itérateur qui permet
de parcourir très facilement un container en s&rsquo;affranchissant complètement de la
manière dont il est implémenté.
</p>

<p>
L&rsquo;objectif de cette introduction n&rsquo;est pas de faire un inventaire exhaustif des
possibilités offertes par la STL, mais d&rsquo;en donner un aperçu au travers
d&rsquo;exemples courants d&rsquo;utilisation. On pourra trouver le détail des classes de la
STL à l&rsquo;adresse suivante :
</p>

<div class="center">
<p>
<a href="http://www.sgi.com/tech/stl/table_of_contents.html">http://www.sgi.com/tech/stl/table_of_contents.html</a>
</p>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Principales classes de la STL</h2>
<div class="outline-text-2" id="text-1">
<p>
Les types de données disponibles sont multiples; cependant, les trois
fréquemment utilisés sont le vecteur, la liste et la table associative. Pour
pouvoir bénéficier de leurs fonctionnalités, les fichiers d&rsquo;entêtes homonymes
doivent être inclus : on utilisera par exemple <code>#include &lt;vector&gt;</code> pour un
vecteur, <code>#include &lt;list&gt;</code> pour une liste, etc. Par ailleurs, l&rsquo;ensemble de ces
containers appartiennent à l&rsquo;espace de nom standard <code>std</code>.  Nous allons plus
spécifiquement discuter des vecteurs et des listes chainées (<code>string</code>), les
opérations sur les autres conteneurs étant similaires du fait de leur
implémentation.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">La classe <code>vector</code></h3>
<div class="outline-text-3" id="text-1-1">
<p>
La classe <code>vector</code> est proche du tableau du C. Tous les éléments contenus dans
le <code>vector</code> sont adjacents en mémoire, ce qui permet d&rsquo;accéder immédiatement à
n&rsquo;importe quel élément. L&rsquo;avantage majeur du <code>vector</code> comparé au tableau du C
réside dans sa faculté à se réallouer automatiquement en cas de besoin lors de
l&rsquo;utilisation de la méthode <code>push_back</code> par exemple. La désallocation est
également simplifiée de par l&rsquo;existence du destructeur de classe. Cependant,
contrairement à un tableau classique, une case n&rsquo;est accessible par l&rsquo;opérateur
<code>[]</code> que si elle a été allouée au préalable (sinon une erreur de segmentation se
déclenche).
</p>

<p>
L&rsquo;exemple ci-dessous présente les principales méthodes issues de la
classe <code>vector</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span> ()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">D&#233;claration d'un vecteur d'entiers de taille non connue</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">myVector</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Ajout de trois &#233;l&#233;ments</span>
  myVector.push_back (4);
  myVector.push_back (2);
  myVector.push_back (5);

  <span class="org-comment-delimiter">// </span><span class="org-comment">La m&#233;thode size pr&#233;cise le nombre d'entr&#233;e courante</span>
  <span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">iEntry</span> = 0; iEntry &lt; myVector.size(); ++iEntry)
    <span class="org-constant">std</span>::cout &lt;&lt; iEntry &lt;&lt; <span class="org-string">" "</span> &lt;&lt; myVector[iEntry] &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Cr&#233;ation d'un vecteur d'entier contenant 70,70,70,70,70</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">mySecondVector</span>(5,70);

  <span class="org-comment-delimiter">// </span><span class="org-comment">R&#233;assignation des valeurs de ce vecteur</span>
  mySecondVector[0] = 5;
  mySecondVector[1] = 3;
  mySecondVector[2] = 7;
  mySecondVector[3] = 4;
  mySecondVector[4] = 8;

  mySecondVector.clear();
}
</pre>
</div>

<p>
Parmi les quelques instructions présentées, on distingue l&rsquo;utilisation de la
méthode <code>push_back</code> qui permet d&rsquo;ajouter un élément en fin de vecteur tout en
réallouant l&rsquo;espace mémoire nécessaire. La méthode <code>push_front</code> réalise
l&rsquo;opération inverse à savoir l&rsquo;ajout d&rsquo;une entrée en début de vecteur. Du fait
du déplacement de l&rsquo;ensemble des valeurs précédemment assignées et allouées en
mémoire, cette méthode nécessite un temps plus conséquent afin de réorganiser la
structure en mémoire du vecteur.
</p>

<p>
On note également l&rsquo;utilisation de la méthode <code>size</code> qui permet de déterminer le
nombre d&rsquo;élément courramment alloué. Il est ainsi possible de parcourir
l&rsquo;ensemble des valeurs &ldquo;recueillies&rdquo; jusqu&rsquo;à présent (nous verrons à la fin de
ce cours, que la notion d&rsquo;itérateur généralise ce mécanisme indépendamment de la
classe mise en jeu).
</p>

<p>
Comme nous le soulignions précédemment, l&rsquo;opérateur <code>[]</code> est également
accessible rendant l&rsquo;utilisation de la classe <code>vector</code> similaire au tableau. On
remarquera toutefois qu&rsquo;il existe la méthode <code>at</code> dont la finalité est identique
à l&rsquo;opérateur <code>[]</code> mais qui vérifie préalablement l&rsquo;existence de l&rsquo;élément. Dans
le cas d&rsquo;un dépassement de mémoire, le programme stoppe de manière plus élégante
qu&rsquo;un <code>segmentation fault</code> en précisant l&rsquo;origine de l&rsquo;arrêt. Enfin, la méthode
<code>clear</code> permet de vider le vecteur de sa substance en ramenant sa taille à 0.
</p>

<div class="remark">
<p>
Il ne faut pas perdre de vue qu&rsquo;une réallocation mémoire est coûteuse en terme
de temps de calcul. Aussi, si la taille d&rsquo;un vecteur est connue par avance, il
faut autant que possible le créer directement à cette taille.
</p>

</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">La classe <code>string</code></h3>
<div class="outline-text-3" id="text-1-2">
<p>
Il est possible en C++ d&rsquo;utiliser les chaînes de caractères héritées du
C. Celui-ci ne disposant pas de type &ldquo;chaîne&rdquo; primitif (c&rsquo;est à dire intégré au
langage), celles-ci sont représentées sous forme de tableaux de caractères
terminés par un <code>\0</code> (caractère ASCII <code>0</code>). Le plus souvent, pour des
raisons de souplesse, les chaînes sont allouées dynamiquement : le type de
données représentant donc les chaînes de caractères en C est <code>char*</code> (qui
signifie pointeur sur caractère ou pointeur sur tableau de caractères : on ne
peut pas faire la différence en C). L&rsquo;ensemble des manipulations classiques sur
les chaînes de caractères est disponible à partir du fichier d&rsquo;entête <code>string.h</code>
(obtention de la longueur, concaténation, copie, segmentation,&#x2026;).
</p>

<p>
Cependant, le fait d&rsquo;utiliser une représentation aussi peu abstraite pose
beaucoup de problèmes en pratique : le code n&rsquo;est pas toujours lisible, et une
certaine attention est requise pour gérer convenablement la mémoire sous peine
d&rsquo;obtenir des fuites mémoire ou, plus grave, des segmentation faults. Afin de
manipuler plus aisément les chaîne de caractères, une classe <code>string</code> a été
définie et intégrée dans la librairie standard.
</p>

<p>
Les chaînes de caractères se trouvent dans le header <code>string</code> (à ne pas
confondre avec <code>string.h</code>, qui contient les fonctionnalités pour manipuler les
chaînes de caractères C). L&rsquo;exemple suivant présente quelques unes des
possibilités offertes par cette classe
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span> ()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Assignation/copie de strings</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString1</span> = <span class="org-string">"abcd"</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString2</span> = myString1;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Initialisation de strings</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString3</span> (myString2);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Concat&#233;nation</span>
  myString2 += <span class="org-string">"abcd"</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString4</span> = myString1 + <span class="org-string">"toto"</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Comparaison</span>
  <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">myBoolean</span> = (myString1 == myString2);
  <span class="org-keyword">if</span> (myBoolean)
    <span class="org-constant">std</span>::cout &lt;&lt; myString1 &lt;&lt; <span class="org-string">" est identique &#224; "</span> &lt;&lt; myString2 &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Longueur d'un string</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">size</span> = myString1.size ();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Recherche dans un string</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">pos</span> = myString1.find (<span class="org-string">"bc"</span>);
}
</pre>
</div>

<p>
On reconnaît entre autre la méthode <code>size</code> qui précise la taille <i>i.e.</i> le
nombre de caractère, d&rsquo;une instance de <code>string</code>. La surcharge des opérateurs
tels que <code>+=</code> ou <code>+</code> permet par ailleurs de concaténer des chaînes de caractères
tandis que la méthode <code>find</code> indique la position à laquelle est trouvée la
première occurence de la chaine de caractère fournie en argument.
</p>

<p>
Nous ne faisons ici, que citer certaines des méthodes les plus communément
utilisées. Le lecteur intéressé pourra se référer aux nombreux ouvrage ainsi
qu&rsquo;aux différentes pages internet traitant du sujet. Nous soulignerons
finalement la possibilité grâce au mécanisme des patrons de déclarer des
vecteurs de chaines de caractères <i>via</i> l&rsquo;instruction <code>vector&lt;string&gt;
myStringVector</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Les itérateurs</h2>
<div class="outline-text-2" id="text-2">
<p>
Un <code>iterator</code> (et sa version constante <code>const_iterator</code>) permet de parcourir un
container du début à la fin en renvoyant un pointeur vers l&rsquo;objet
sélectionné. Un <code>const_iterator</code>, contrairement à un <code>iterator</code>, donne un accès
uniquement en lecture à l&rsquo;élément &ldquo;pointé&rdquo;. Ainsi, un parcours avec des
<code>const_iterator</code> maintient la constance de l&rsquo;objet et ne permettra pas de le
modifier. C&rsquo;est pourquoi un container &ldquo;<code>const</code>&rdquo; peut être parcouru par des
<code>const_iterator</code> et non par des <code>iterator</code>. De manière générale, quand on a le
choix entre des <code>iterator</code> ou des <code>const_iterator</code>, il faut toujours privilégier
les <code>const_iterator</code> car ils rendent la section de code à laquelle ils servent
plus générique (applicable aux containers constants ou non).
</p>

<p>
Appliqué au containers de la STL, on trouve ainsi les méthodes
</p>

<ul class="org-ul">
<li><code>begin()</code> qui retourne un <code>iterator</code> pointant sur le premier élément,
</li>

<li><code>end()</code> qui retourne un <code>iterator</code> pointant juste &ldquo;après&rdquo; le dernier élément,
</li>

<li>l&rsquo;opérateur <code>++</code> qui permet d&rsquo;incrémenter l&rsquo;<code>iterator</code> en le faisant
passer à l&rsquo;élément suivant.
</li>
</ul>

<p>
À titre d&rsquo;exemple, le programme suivant explicite leur utilisation
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-function-name">setVector</span>()
{
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">v</span>;
  v.push_back(<span class="org-string">"John"</span>);
  v.push_back(<span class="org-string">"Deuf"</span>);
  <span class="org-keyword">return</span> v;
}

<span class="org-type">int</span> <span class="org-function-name">main</span> ()
{
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">myVector</span>(<span class="org-type">setVector</span>());

  <span class="org-comment-delimiter">// </span><span class="org-comment">ne compile pas car myVector est const</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">std::vector&lt;string&gt;::iterator itVector;</span>
  <span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">string</span>&gt;::<span class="org-type">const_iterator</span> <span class="org-variable-name">itVector</span>;

  <span class="org-keyword">for</span> (itVector = myVector.begin(); itVector != myVector.end(); ++itVector)
    cout &lt;&lt; *itVector &lt;&lt; endl;
}
</pre>
</div>

<p>
Dans le même esprit, il existe également les contreparties <code>reverse_iterator</code> et
<code>const_reverse_iterator</code> qui parcourent l&rsquo;instance de la fin vers le début.
</p>
</div>
</div>
</div>
</body>
</html>
