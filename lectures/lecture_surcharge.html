<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Surdéfinition d&rsquo;opérateur</title>
<!-- 2013-10-19 sam. 07:37 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><aa>Encapsulation des données </aa><aa>Notions de constructeur et de destructeur </aa><aa>Fonctions et classes amies </aa><aa>Surcharge d'opérateur </aa><aa>Héritage </aa><aa>Notions de patrons de fonctions et de classes </aa><aa>Introduction à la librairie standard STL </aa><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><aa>Les membres données statiques </aa><aa>Utilisation de enum et de typedef </aa>
                    <hr/>
                    <a href="../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Surdéfinition d&rsquo;opérateur</h1><hr/>
<p>
Le C++ permet de surdéfinir les opérateurs<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> c&rsquo;est-à-dire de donner un sens
différent à un symbole selon le contexte. Cette possibilité tient au fait que
les opérateurs ne se différencient des fonctions que syntaxiquement, pas
logiquement. À ce titre, le compilateur traite un appel à un opérateur comme un
appel à une fonction. On pourra donc surdéfinir ou surcharger un opérateur dès
lors que la nouvelle définition se différenciera, sans ambiguité, des
précédentes. Par exemple, surdéfinir l&rsquo;opérateur <code>+</code> permet que l&rsquo;addition
<i>i.e.</i> le symbole <code>+</code> binaire, n&rsquo;ait pas le même sens s&rsquo;il agit sur deux entiers
ou si l&rsquo;addition porte sur deux objets de la classe <code>point</code>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Surcharge des opérateurs internes</h2>
<div class="outline-text-2" id="text-1">
<p>
Une première méthode pour surcharger les opérateurs consiste à les considérer
comme des méthodes de la classe sur laquelle ils s&rsquo;appliquent. Le nom de ces
méthodes est donné par le mot clé <code>operator</code>, suivi de l&rsquo;opérateur à
surcharger. Le type de la fonction est le type du résultat donné par
l&rsquo;opération, et les paramètres, donnés en argument, sont les opérandes. La
syntaxe est la suivante :
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">type</span> <span class="org-function-name">operatorOp</span> (argument)
</pre>
</div>
<p>
L&rsquo;écriture <code>A Op B</code> où <code>Op</code> est, par exemple, <code>+,=,*=</code>&#x2026; se traduit par
</p>
<div class="org-src-container">

<pre class="src src-c++">A.operatorOp (B)
</pre>
</div>
<p>
Le premier opérande est toujours l&rsquo;objet auquel cette fonction s&rsquo;applique. Cette
manière de surcharger les opérateurs est donc particulièrement adaptée pour les
opérateurs qui modifient l&rsquo;objet sur lequel ils travaillent tels que les
opérateurs <code>=, +</code>, ++=&#x2026;. Par ailleurs, les opérateurs (sur)définis en
interne devront souvent renvoyer l&rsquo;objet sur lequel ils travaillent (ce n&rsquo;est
pas une nécessité cependant). On utilisera alors le pointeur <code>this</code> qui pointe
sur l&rsquo;adresse de l&rsquo;objet qui a appelé la méthode de surdéfinition.
</p>

<p>
Afin d&rsquo;illustrer les propriétés définies dans ce paragraphe, nous proposons
quelques exemples d&rsquo;implémentation de surdéfinition d&rsquo;opérateurs en relation
avec la classe <code>complexe</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">class</span> <span class="org-type">complexe</span> {
<span class="org-keyword">public</span>:
  <span class="org-function-name">complexe</span> (<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">reel</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">img</span>);
  <span class="org-type">complexe</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">+=</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>);
  <span class="org-type">complexe</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">*=</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>);
  ...

  <span class="org-keyword">private</span>:
  <span class="org-type">double</span> m_reel;
  <span class="org-type">double</span> <span class="org-variable-name">m_imaginaire</span>;
};

<span class="org-constant">complexe</span>::<span class="org-function-name">complexe</span> (<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">reel</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">img</span>) :
  m_reel(reel), m_imaginaire(img) {};

<span class="org-type">complexe</span>&amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">+=</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>) {
  m_reel       += source.m_reel;
  m_imaginaire += source.m_imaginaire();
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}

<span class="org-type">complexe</span>&amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">*=</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>) {
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">tmp</span> = m_reel*source.m_reel - m_imaginaire*source.m_imaginaire;
  m_imaginaire = m_reel*source.m_imaginaire + m_imaginaire*source.m_reel;
  m_reel = tmp;
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}
</pre>
</div>

<div class="remark">
<p>
Comme pour toute surdéfinition de fonction, le compilateur choisit, selon le
contexte, quelle surcharge d&rsquo;opérateur utiliser. Ainsi, on pourra, selon les
besoins, surcharger l&rsquo;opérateur <i><code>+=</code></i> de l&rsquo;exemple précédent en fournissant en
argument non plus un objet <i><code>Complexe</code></i> sinon un entier ou un double. La
définition de la méthode sera
</p>
<div class="org-src-container">

<pre class="src src-c++">complexe&amp; <span class="org-keyword">operator</span>+= (<span class="org-keyword">const</span> <span class="org-type">double</span>&amp; <span class="org-variable-name">a</span>);
</pre>
</div>

</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Surcharge des opérateurs en externe</h2>
<div class="outline-text-2" id="text-2">
<p>
La définition de l&rsquo;opérateur ne se fait plus dans la classe qui l&rsquo;utilise, mais
en dehors de celle-ci par surcharge d&rsquo;un opérateur de l&rsquo;espace de
nommage. L&rsquo;opérateur surdéfini est déclaré comme une fonction travaillant avec
la classe dont l&rsquo;opérateur doit être surchargé. Pour que cette fonction puisse
accéder aux membres de la classe, elle est généralement définie comme fonction
amie (<code>friend</code>). Le prototype est le suivant
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">friend</span> <span class="org-type">type</span> <span class="org-function-name">operatorOp</span> (argument);
</pre>
</div>

<p>
À titre d&rsquo;exemple, on pourra surcharger l&rsquo;opérateur <code>+</code> de la classe <code>complexe</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">z1</span>, <span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">z2</span>) <span class="org-keyword">const</span>
{
  <span class="org-keyword">return</span> complexe(z1.m_reel + z2.m_reel, z1.m_imaginaire + z2.m_imaginaire);
}
</pre>
</div>

<div class="remark">
<p>
On notera bien que la surcharge de l&rsquo;opérateur est extérieure à la classe
<i><code>complexe</code></i> : sa déclaration ne fait pas intervenir l&rsquo;opérateur de portée
<i><code>::</code></i>. Par ailleurs, la déclaration précédente suppose que la construction
<i><code>complexe (const double, const double)</code></i> est envisageable.
</p>

</div>

<p>
L&rsquo;avantage de cette syntaxe est que l&rsquo;opérateur est réellement symétrique,
contrairement au cas où les opérateurs sont définis à l&rsquo;intérieur de la classe.
</p>
</div>

<div id="outline-container-sec-2-0-1" class="outline-4">
<h4 id="sec-2-0-1">Remarques importantes</h4>
<div class="outline-text-4" id="text-2-0-1">
<ul class="org-ul">
<li>Lorsque l&rsquo;on surdéfinit un opérateur, c&rsquo;est à priori pour l&rsquo;utiliser à
plusieurs reprises. Il faut donc apporter un soin particulier à l&rsquo;optimisation
du code. En conséquence, il est important de savoir si l&rsquo;on déclare ou non la
fonction <code>inline</code>
</li>

<li>Dans le cas d&rsquo;opérateur unaire tel que l&rsquo;opérateur <code>-()</code> qui effectue la
transformation <code>z\longmapsto-z</code>, la (sur)définition de la fonction ne prend
pas d&rsquo;argument. On écrit alors
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">-</span> () <span class="org-keyword">const</span>
{
  <span class="org-keyword">return</span> complexe(-m_reel, -m_imaginaire);
}
</pre>
</div>
</li>

<li>De manière générale, si une méthode ne modifie pas les membres de la classe,
on ajoute à la fin de sa définition, le mot clé <code>const</code> (<i>cf.</i> exemple
précédent). Cette remarque prend toute son importance lorsque l&rsquo;on manipule
les opérateurs permettant ainsi de s&rsquo;assurer que les membres ne sont pas
modifiés de manière inopportune.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Constructeur de recopie et opérateur d&rsquo;affectation <code>=</code></h2>
<div class="outline-text-2" id="text-3">
<p>
L&rsquo;opérateur d&rsquo;affectation <code>=</code> peut lui aussi être redéfini. Cependant, son rôle
peut parfois interférer avec celui du constructeur de recopie. De même que le
constructeur est la fonction appelée lors de la création d&rsquo;un objet, le
constructeur de recopie est appelé lors de la copie d&rsquo;un objet vers un autre
objet du même type (<i>e.g.</i> une instruction du type <code>z1 = z2;</code> où <code>z1</code> et <code>z2</code> sont
des instances de la classe <code>complexe</code>).
</p>

<p>
La définition du constructeur de recopie est voisine de celle du constructeur
par défaut sachant toutefois que le constructeur de recopie possède comme
argument <b>une référence vers la classe</b>. Ainsi, son prototype s&rsquo;écrit:
</p>
<div class="org-src-container">

<pre class="src src-c++">nom_classe (<span class="org-type">nom_classe</span>&amp;);
</pre>
</div>
<p>
tandis que sa déclaration est
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-constant">nom_classe</span>::nom_classe (nom_classe&amp; objet_de_type_nom_classe);
</pre>
</div>

<p>
Exemple:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-constant">complexe</span>::<span class="org-function-name">complexe</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp;<span class="org-variable-name">source</span>)
{
  m_reel       = source.m_reel;
  m_imaginaire = source.m_imaginaire;
}
</pre>
</div>

<p>
L&rsquo;opérateur d&rsquo;affectation <code>=</code> se définit comme toute surcharge d&rsquo;opérateur et sa
déclaration devient
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span>&amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span> (<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>)
{
  <span class="org-keyword">if</span> (&amp;source != <span class="org-keyword">this</span>)
    {
      m_reel       = source.m_reel;
      m_imaginaire = source.m_imaginaire;
    }
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}
</pre>
</div>

<p>
Du point de vue de la syntaxe, la surcharge d&rsquo;opérateur d&rsquo;affectation est
voisine de celle du constructeur de recopie. Néanmoins, la surcharge de
l&rsquo;opérateur d&rsquo;affectation signale bien souvent que la classe n&rsquo;a pas une
structure simple (présence d&rsquo;un pointeur en particulier) et qu&rsquo;en conséquence,
le constructeur de recopie et le destructeur par défaut, fournis par le
compilateur, ne suffisent pas. Il faut donc veiller à respecter la règle des
trois, qui stipule que si l&rsquo;une des ces méthodes est redéfinie, il faut que les
trois le soient. Par ailleurs, si le constructeur de recopie n&rsquo;est pas redéfini,
les écritures telles que :
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">classe</span> <span class="org-variable-name">objet</span> = source;
</pre>
</div>
<p>
ne fonctionnent pas correctement. En effet, c&rsquo;est le constructeur de recopie qui
est appelé dans ce cas, et non l&rsquo;opérateur d&rsquo;affectation comme le suggère la
syntaxe.
</p>

<p>
Un autre problème important tient à l&rsquo;autoaffectation. Non seulement affecter un
objet à lui-même est inutile et consommateur de ressources, mais de plus, cela
peut s&rsquo;avérer dangereux : l&rsquo;affectation risque de détruire les données membres
de l&rsquo;objet avant même qu&rsquo;elles ne soient copiées, ce qui provoque au final ni
plus ni moins que la destruction de l&rsquo;objet. Une solution simple présentée dans
l&rsquo;exemple précédent consiste à ajouter un test sur l&rsquo;objet source en début de
surcharge d&rsquo;opérateur : <code>if (&amp;source !=</code> <code>this)</code>.
</p>

<p>
Pour toutes ces raisons, la surcharge de l&rsquo;opérateur d&rsquo;affectation s&rsquo;avère une
opération souvent délicate. Dans la grande majorité des cas, on évitera de
surcharger l&rsquo;opérateur d&rsquo;affectation en utilisant le constructeur de recopie par
défaut.
</p>
</div>

<div id="outline-container-sec-3-0-1" class="outline-4">
<h4 id="sec-3-0-1">Remarques générales</h4>
<div class="outline-text-4" id="text-3-0-1">
<ul class="org-ul">
<li>l&rsquo;opérateur <code>()</code> est intéressant car il est &ldquo;n-unaire&rdquo;.
</li>

<li>il est aussi possible de surdéfinir :
<ul class="org-ul">
<li>les opérateurs de transtypage (ou de casting)
</li>
<li>les opérateurs de déférencement <code>*</code> et d&rsquo;indirection <code>&amp;</code>
</li>
<li><code>new</code> et <code>delete</code>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
on parle également de surcharge d&rsquo;opérateur
</p></div>


</div>
</div></div>
</body>
</html>
